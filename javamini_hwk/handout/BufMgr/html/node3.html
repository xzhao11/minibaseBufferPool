<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--Converted with LaTeX2HTML 97.1 (release) (July 13th, 1997)
 by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippman, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Internal Design</TITLE>
<META NAME="description" CONTENT="Internal Design">
<META NAME="keywords" CONTENT="BufMgr">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
<LINK REL="STYLESHEET" HREF="BufMgr.css">
<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="BufMgr.html">
<LINK REL="next" HREF="node4.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html39"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="http://www.cs.wisc.edu/icons/latex2html/next_motif.gif"></A> 
<A NAME="tex2html37"
 HREF="BufMgr.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="http://www.cs.wisc.edu/icons/latex2html/up_motif.gif"></A> 
<A NAME="tex2html31"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="http://www.cs.wisc.edu/icons/latex2html/previous_motif.gif"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html40"
 HREF="node4.html">Where to Find Makefiles,</A>
<B> Up:</B> <A NAME="tex2html38"
 HREF="BufMgr.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html32"
 HREF="node2.html">The Buffer Manager Interface</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<H1><A NAME="SECTION00030000000000000000">
Internal Design</A>
</H1>
<P>
The <EM>buffer pool</EM> is a collection of <EM>frames</EM> (page-sized 
sequence of main memory bytes) that is managed by the Buffer Manager.
Conceptually, it should be stored as an array bufPool[numbuf] of 
Page objects.  However, due to the limitation of Java language, it
is not feasible to declare an array of Page objects and later on 
writing string (or other primitive values) to the defined Page.
To get around the problem, we have defined our Page as an array of 
bytes and deal with buffer pool at the byte array level.  Therefore, 
when implement your constructor for the BufMgr class, you should declare
the buffer pool as <EM>bufpool[numbuf][page_size]</EM>.  Note that the
size of minibase pages is defined in the interface <EM>GlobalConst</EM> of
the <EM>global</EM> package.  Before jump into coding, please make sure
that you understand how Page object is defined and manipulated in Java
minibase.
<P>
In addition, you should maintain an array bufDescr[numbuf] of 
<EM>descriptors</EM>, one per frame.  Each descriptor is a record with 
the following fields:
<BLOCKQUOTE>
<EM>page number, pin_count, dirtybit</EM>.
</BLOCKQUOTE>
The <EM>pin_count</EM> field is an
integer, <EM>page number</EM> is a PageId object, and <EM>dirtybit</EM>  
is a boolean. This describes the page that is stored in the corresponding frame.
A page is identified by
a <EM>page number</EM> that is
generated by the DB class when the page is allocated, and is unique over all
pages in the database. 
The PageId type is defined as an integer type in minirel.h.
<P>
A simple <EM>hash table</EM> should be used to figure out 
what frame a given disk page occupies.  
The hash table should be implemented (entirely in main memory)
by using an array of pointers to lists of
<IMG WIDTH="9" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="img1.gif"
 ALT="$\langle$"> <EM>page number, frame number</EM> <IMG WIDTH="9" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.gif"
 ALT="$\rangle$"> pairs.  
The array is called the <EM>directory</EM> and each list of
pairs is called a <EM>bucket</EM>.  Given a <EM>page number</EM>, you
should apply a <EM>hash function</EM> to find the directory entry
pointing to the bucket that contains the frame number for this page, if the
page is in the buffer pool.  If you search the bucket and don't find
a pair containing this page number, the page is not in the pool.
If you find such a pair, it will tell you the frame in which the page
resides.  This is illustrated in Figure <A HREF="node3.html#assign1fig">1</A>.
<P>
<BR>
<DIV ALIGN="CENTER"><A NAME="assign1fig">&#160;</A><A NAME="45">&#160;</A>
<TABLE>
<CAPTION><STRONG>Figure 1:</STRONG>
Hash Table</CAPTION>
<TR><TD><IMG WIDTH="582" HEIGHT="312"
 SRC="img3.gif"
 ALT="\begin{figure}
\centerline{
\psfig {figure=assign1fig.eps}
}\end{figure}"></TD></TR>
</TABLE>
</DIV>
<BR>
<P>
The hash function
must distribute values in the domain of the search field
uniformly over the collection of buckets.
If we have HTSIZE buckets, numbered 0 through M-1, a hash
function <I>h</I> of the form <I>h</I>(<I>value</I>)&nbsp;=&nbsp;(<I>a</I>*<I>value</I>+<I>b</I>)&nbsp;<I>mod</I>&nbsp;<I>HTSIZE</I>
works well in practice.  HTSIZE should be chosen to be a prime number.
<P>
When a page is requested the buffer manager should do the following:
<DL COMPACT>
<DT>1.
<DD>Check the buffer pool (by using the hash table) to see if it contains the requested page.
If the page is not in the pool, it should be brought in as follows:
<DL COMPACT>
<DT>(a)
<DD>Choose a frame for replacement,
using the Clock replacement policy.
<DT>(b)
<DD>If the frame chosen for replacement is dirty, 
<EM>flush</EM> it (i.e., write out the page that it contains to disk,
using the appropriate DB class method).
<DT>(c)
<DD>Read the requested page (again, by calling the DB class) into the frame chosen for replacement; the 
<EM>pin_count</EM> and <EM>dirtybit</EM> for the frame
should be initialized to 0 and FALSE, respectively.
<DT>(d)
<DD>Delete the entry for the old page from the Buffer Manager's hash table and insert
an entry for the new page.
Also, update the entry for this frame in the bufDescr array to reflect these changes.
</DL>
<DT>2.
<DD><EM>Pin</EM> the requested page by incrementing the <EM>pin_count</EM> in the descriptor
for this frame.
and return a pointer to the page to the requestor.  
</DL>
<P>
To implement the Clock replacement policy, maintain a 
queue of frame numbers.
When a frame is to be chosen for replacement, you should pick the first frame 
in this list.
A frame number is added to the end of the queue when the <EM>pin_count</EM> for
the frame is decremented to 0.
A frame number is removed from the queue if the <EM>pin_count</EM> becomes
non-zero:  this could happen if there is a request for the page currently in
the frame!
<P><HR>
<!--Navigation Panel-->
<A NAME="tex2html39"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="http://www.cs.wisc.edu/icons/latex2html/next_motif.gif"></A> 
<A NAME="tex2html37"
 HREF="BufMgr.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="http://www.cs.wisc.edu/icons/latex2html/up_motif.gif"></A> 
<A NAME="tex2html31"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="http://www.cs.wisc.edu/icons/latex2html/previous_motif.gif"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html40"
 HREF="node4.html">Where to Find Makefiles,</A>
<B> Up:</B> <A NAME="tex2html38"
 HREF="BufMgr.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html32"
 HREF="node2.html">The Buffer Manager Interface</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Qingqing Ouyang</I>
<BR><I>11/24/1998</I>
</ADDRESS>
</BODY>
</HTML>
